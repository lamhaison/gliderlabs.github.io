<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Glider Labs - programming</title>
  <subtitle>Infrastructure building blocks designed for humans</subtitle>
  <id>http://gliderlabs.com/blog</id>
  <link href="http://gliderlabs.com/blog"/>
  <link href="http://gliderlabs.com/blog/tags/programming.xml" rel="self"/>
  <updated>2015-08-04T12:20:00-05:00</updated>
  <author>
    <name>Glider Labs</name>
    <email>team@gliderlabs.com</email>
  </author>
  <entry>
    <title>High-performance messaging expertise</title>
    <link rel="alternate" href="http://gliderlabs.com/blog/2015/08/04/high-performance-messaging/"/>
    <id>http://gliderlabs.com/blog/2015/08/04/high-performance-messaging/</id>
    <published>2015-08-04T12:20:00-05:00</published>
    <updated>2015-08-10T13:24:23-05:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;Messaging systems excite me more than they should. Perhaps because they&amp;rsquo;re so
foundational to distributed systems. Yet there&amp;rsquo;s tons of deep architectural
knowledge, both high-level and low-level that&amp;rsquo;s not well known. There are a
handful of messaging domain experts that I love hearing from, and one of them is
&lt;a href="http://mechanical-sympathy.blogspot.com/"&gt;Martin Thompson&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Last year at Strange Loop, Martin gave a talk on a high-performance messaging
project called Aeron. I&amp;rsquo;m sharing this talk less for the project, and more for the
knowledge and findings associated with the project:&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/tM4YskS94b0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Not mentioned a whole lot in this talk is his notion of &amp;ldquo;mechanical sympathy,&amp;rdquo;
which came up with the &lt;a href="http://martinfowler.com/articles/lmax.html"&gt;LMAX architecture&lt;/a&gt;
everybody was raving about a few years ago. The simple idea of aligning our
software to the strengths of our underlying hardware, and avoiding operations
our hardware is not great at.&lt;/p&gt;

&lt;p&gt;About 80% of our software will never need this level of optimization. That said,
I think the lessons learned from those like Martin Thompson should be more well
known.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Build simple systems to build good systems</title>
    <link rel="alternate" href="http://gliderlabs.com/blog/2015/04/29/build-simple-systems-to-build-good-systems/"/>
    <id>http://gliderlabs.com/blog/2015/04/29/build-simple-systems-to-build-good-systems/</id>
    <published>2015-04-29T06:18:00-05:00</published>
    <updated>2015-08-10T13:23:51-05:00</updated>
    <author>
      <name>Jeff Lindsay</name>
    </author>
    <content type="html">&lt;p&gt;We often talk about complexity in software systems, but for some reason we don&amp;rsquo;t seem to talk enough about simplicity. I was quite happy to find that Rich Hickey&amp;rsquo;s keynote at Strange Loop 2011 focused on simplicity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href="http://www.infoq.com/presentations/Simple-Made-Easy"&gt;Rich Hickey - Simple Made Easy on InfoQ&lt;/a&gt;&lt;/strong&gt; (&lt;a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md"&gt;transcript&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Simple Made Easy is about Hickey&amp;rsquo;s exploration of what simple really means, what it doesn&amp;rsquo;t mean, and how that can be used as a guide towards simplicity in software.&lt;/p&gt;

&lt;p&gt;Most experienced programmers know that simplicity is difficult to achieve. Perhaps part of the reason for this is that simplicity seems to be somewhat subjective. Here, Hickey explains a framework to more objectively identify how simple a design is.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img alt="Simple as not interleaved" src="/images/simple_made_easy.jpg" /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;He starts with the etymology of simple. It describes a meaning around the amount of &lt;em&gt;interleaving&lt;/em&gt;. What&amp;rsquo;s interesting is that this interpretation of simplicity is not about the number of elements, just how interleaved they are.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Simplicity is not about counting. I&amp;rsquo;d rather have more things hanging nice, straight down, not twisted together, than just a couple of things tied in a knot.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To help with this particular meaning of simple, he shares an archaic word that is specifically the opposite of this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;complect&lt;/strong&gt; - to interleave, entwine, or braid&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By using complecting as our primary anti-pattern, we can more easily see a path towards simplicity than the vague notion of &amp;ldquo;avoiding complexity.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;He also identifies that simple is not the same as easy, despite many using those words interchangeably. While easy is ultimately relative, simple in these terms has some objectivity to it. We can ask, &amp;ldquo;How much interleaving is there?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The talk goes over a number tactical approaches to simplicity by not complecting, but there&amp;rsquo;s also wisdom shared around the value of simplicity.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest issue with complexity is that it undermines understanding your software. He makes the point that understanding is the real key to making changes quickly in software.&lt;/p&gt;

&lt;p&gt;Conventional wisdom says testing is how we can make changes quickly. While there is clearly value in testing, the popular notion that test coverage above all else is what you need to move quickly is challenged by Hickey. He calls it guardrail programming.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What&amp;rsquo;s true of every bug found in the field? It passed all the tests. So now what do you do? I think we&amp;rsquo;re in this world I&amp;rsquo;d like to call guardrail programming. It&amp;rsquo;s really sad. We&amp;rsquo;re like, &amp;ldquo;I can make change because I have tests!&amp;rdquo; Who does that? Who drives their car around banging against the guardrail saying, &amp;ldquo;Whoa! I&amp;rsquo;m glad I&amp;rsquo;ve got these guardrails because I&amp;rsquo;d never make it to the show on time.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Once you find a bug, tests only tell you what the problem isn&amp;rsquo;t. You have to reason about the program, debug it, try things. If the program is complex, this is harder to do. The only way to improve this process is if the program is simple.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compared to the complexity we can create, we&amp;rsquo;re all statistically at the same point in our ability to understand it, which is not very good. So we&amp;rsquo;re going to have to bring things towards us.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There&amp;rsquo;s definitely a lot of great insight in this talk. As a final point, let&amp;rsquo;s remember that simplicity doesn&amp;rsquo;t just happen. It&amp;rsquo;s not the default mode of software engineering.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Simplicity is a choice. It requires constant vigilance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need more thinking around simplicity. If you know of other great talks on simplicity, in software or otherwise, please share in the comments.&lt;/p&gt;
</content>
  </entry>
</feed>
